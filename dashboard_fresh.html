<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Income Generator - Weekly Distribution ETF Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;            allocationDiv.innerHTML = sortedAllocation.map(asset => {
                const weightPercent = (asset.weight * 100).toFixed(1);
                // Display CASH more intuitively
                const displayName = asset.ticker === 'CASH' ? 'üí∞ Cash (Risk-Free)' : asset.ticker;
                return `
                    <div class="allocation-row">
                        <span class="allocation-name">${displayName}</span>
                        <span class="allocation-percent">${weightPercent}%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${weightPercent}%"></div>
                    </div>
                `;
            }).join('');  color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #2196f3, #00bcd4);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 15px;
        }

        .timestamp {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 25px;
            display: inline-block;
            font-size: 0.9rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
        }

        .card-icon {
            width: 40px;
            height: 40px;
            background: transparent;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 20px;
        }

        .card-title {
            font-size: 1.8rem;
            font-weight: 700;
        }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        td {
            padding: 15px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .ticker {
            font-weight: 700;
            font-size: 1.1rem;
            color: #81c784;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .ticker:hover {
            color: #4caf50;
            text-decoration: underline;
        }

        .positive {
            color: #4caf50;
            font-weight: 600;
        }

        .negative {
            color: #f48fb1;
            font-weight: 600;
        }

        .strategy-chip {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .dc-chip {
            background: #9c27b0;
            color: white;
        }

        .bh-chip {
            background: #2196f3;
            color: white;
        }

        .risk-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .allocation-list {
            margin-top: 20px;
        }

        .allocation-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .allocation-name {
            font-weight: 600;
            color: #81c784;
        }

        .allocation-percent {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #81c784);
            border-radius: 4px;
            transition: width 1s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 25px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: #4caf50;
        }

        th.sorted-asc::after {
            content: ' ‚ñ≤';
            color: #4caf50;
        }

        th.sorted-desc::after {
            content: ' ‚ñº';
            color: #4caf50;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Portfolio Income Generator</h1>
            <div class="subtitle">Risk-Balanced Weekly Distribution ETF Analysis</div>
            <div class="timestamp">Last Updated: July 18, 2025</div>
        </header>

        <div class="main-grid">
            <div class="card">
                <div class="card-header">
                    <div class="card-icon">üìä</div>
                    <div class="card-title">Top Performing ETFs</div>
                </div>
                <p style="opacity: 0.8; margin-bottom: 20px;">
                    ETFs with annualized returns above 40% and risk below 40% (best of Buy & Hold or Dividend Capture strategies)
                </p>
                
                <div class="table-container">
                    <table id="top-performers">
                        <thead>
                            <tr>
                                <th data-column="ticker">Ticker</th>
                                <th data-column="exDivDay">Ex-Div</th>
                                <th data-column="buyHoldReturn">B&H Return</th>
                                <th data-column="divCaptureReturn">DC Return</th>
                                <th data-column="bestStrategy">Best Strategy</th>
                                <th data-column="bestReturn">Best Return</th>
                                <th data-column="dcWinRate">Win Rate</th>
                                <th data-column="riskVolatility">Risk</th>
                            </tr>
                        </thead>
                        <tbody id="top-performers-body">
                            <!-- Will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="mpt-widget" class="card">
                <div class="card-header">
                    <div class="card-icon" style="color: #ffd54f;">‚öñÔ∏è</div>
                    <div class="card-title">Optimal Allocation</div>
                </div>
                
                <div class="allocation-list" id="portfolio-allocation">
                    <!-- Will be populated by JavaScript -->
                </div>

                <div class="stats-grid" id="portfolio-metrics">
                    <!-- Will be populated by JavaScript -->
                </div>

                <p style="text-align: center; margin-top: 20px; font-size: 0.85rem; opacity: 0.7;">
                    Diversified optimization: Includes all ETFs with >40% return and <40% risk, then maximizes returns within 10% portfolio risk constraint
                </p>
            </div>
        </div>
    </div>

    <footer style="text-align: center; margin-top: 40px; padding: 20px; opacity: 0.7; font-size: 0.85rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        <p style="margin-bottom: 10px;">
            <strong>Disclaimer:</strong> This analysis is for educational and informational purposes only. 
            Past performance does not guarantee future results. All investments carry risk of loss.
        </p>
        <p style="margin: 0;">
            YieldMax ETF data sourced from Yahoo Finance. Trading strategies are hypothetical and do not account for transaction costs, taxes, or market impact.
            Consult with a qualified financial advisor before making investment decisions.
        </p>
    </footer>

    <script>
        let currentData = [];
        let currentSortColumn = null;
        let currentSortDirection = 'asc';

        // Embedded data for immediate display (expanded dataset)
        const fallbackData = [
            {
                        "ticker": "YMAX",
                        "tradingDays": 43,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.9836,
                        "divCaptureReturn": 1.0358,
                        "bestStrategy": "DC",
                        "bestReturn": 1.0358,
                        "finalValue": 203579.0,
                        "dcWinRate": 0.93,
                        "riskVolatility": 0.266,
                        "medianDividend": 0.172,
                        "category": "top-performers"
            },
            {
                        "ticker": "LFGY",
                        "tradingDays": 25,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.4021,
                        "divCaptureReturn": 0.7917000000000001,
                        "bestStrategy": "DC",
                        "bestReturn": 0.7917000000000001,
                        "finalValue": 179172.0,
                        "dcWinRate": 0.88,
                        "riskVolatility": 0.485,
                        "medianDividend": 0.475,
                        "category": "excluded"
            },
            {
                        "ticker": "YMAG",
                        "tradingDays": 43,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.6795,
                        "divCaptureReturn": 0.7789,
                        "bestStrategy": "DC",
                        "bestReturn": 0.7789,
                        "finalValue": 177889.0,
                        "dcWinRate": 0.884,
                        "riskVolatility": 0.254,
                        "medianDividend": 0.158,
                        "category": "top-performers"
            },
            {
                        "ticker": "ULTY",
                        "tradingDays": 18,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.6775,
                        "divCaptureReturn": 0.4974,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.6775,
                        "finalValue": 167750.0,
                        "dcWinRate": 0.889,
                        "riskVolatility": 0.33299999999999996,
                        "medianDividend": 0.095,
                        "category": "top-performers"
            },
            {
                        "ticker": "COII",
                        "tradingDays": 4,
                        "exDivDay": "Tuesday",
                        "buyHoldReturn": 0.5154,
                        "divCaptureReturn": -0.015600000000000001,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.5154,
                        "finalValue": 151544.0,
                        "dcWinRate": 0.75,
                        "riskVolatility": 0.596,
                        "medianDividend": 0.309,
                        "category": "excluded"
            },
            {
                        "ticker": "IWMY",
                        "tradingDays": 34,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.4594,
                        "divCaptureReturn": 0.436,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.4594,
                        "finalValue": 145937.0,
                        "dcWinRate": 0.882,
                        "riskVolatility": 0.188,
                        "medianDividend": 0.27,
                        "category": "top-performers"
            },
            {
                        "ticker": "CHPY",
                        "tradingDays": 13,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.45770000000000005,
                        "divCaptureReturn": 0.2271,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.45770000000000005,
                        "finalValue": 145773.0,
                        "dcWinRate": 0.769,
                        "riskVolatility": 0.19699999999999998,
                        "medianDividend": 0.38,
                        "category": "top-performers"
            },
            {
                        "ticker": "RDTE",
                        "tradingDays": 42,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.4153,
                        "divCaptureReturn": 0.3467,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.4153,
                        "finalValue": 141531.0,
                        "dcWinRate": 0.7859999999999999,
                        "riskVolatility": 0.215,
                        "medianDividend": 0.265,
                        "category": "top-performers"
            },
            {
                        "ticker": "GPTY",
                        "tradingDays": 23,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.301,
                        "divCaptureReturn": 0.38689999999999997,
                        "bestStrategy": "DC",
                        "bestReturn": 0.38689999999999997,
                        "finalValue": 138690.0,
                        "dcWinRate": 0.826,
                        "riskVolatility": 0.361,
                        "medianDividend": 0.293,
                        "category": "excluded"
            },
            {
                        "ticker": "AAPW",
                        "tradingDays": 19,
                        "exDivDay": "Monday",
                        "buyHoldReturn": -0.06709999999999999,
                        "divCaptureReturn": 0.35259999999999997,
                        "bestStrategy": "DC",
                        "bestReturn": 0.35259999999999997,
                        "finalValue": 135256.0,
                        "dcWinRate": 0.737,
                        "riskVolatility": 0.467,
                        "medianDividend": 0.232,
                        "category": "excluded"
            },
            {
                        "ticker": "MST",
                        "tradingDays": 8,
                        "exDivDay": "Wednesday",
                        "buyHoldReturn": 0.2834,
                        "divCaptureReturn": 0.0709,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.2834,
                        "finalValue": 128337.0,
                        "dcWinRate": 0.75,
                        "riskVolatility": 0.833,
                        "medianDividend": 0.272,
                        "category": "excluded"
            },
            {
                        "ticker": "BLOX",
                        "tradingDays": 1,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.2452,
                        "divCaptureReturn": 0.0381,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.2452,
                        "finalValue": 124522.0,
                        "dcWinRate": 1.0,
                        "riskVolatility": 0.36,
                        "medianDividend": 0.145,
                        "category": "excluded"
            },
            {
                        "ticker": "MSII",
                        "tradingDays": 4,
                        "exDivDay": "Tuesday",
                        "buyHoldReturn": 0.2275,
                        "divCaptureReturn": 0.046799999999999994,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.2275,
                        "finalValue": 122746.0,
                        "dcWinRate": 1.0,
                        "riskVolatility": 0.488,
                        "medianDividend": 0.247,
                        "category": "excluded"
            },
            {
                        "ticker": "RDTY",
                        "tradingDays": 17,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.204,
                        "divCaptureReturn": 0.1295,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.204,
                        "finalValue": 120397.0,
                        "dcWinRate": 0.706,
                        "riskVolatility": 0.319,
                        "medianDividend": 0.33,
                        "category": "excluded"
            },
            {
                        "ticker": "SDTY",
                        "tradingDays": 21,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.1139,
                        "divCaptureReturn": 0.1759,
                        "bestStrategy": "DC",
                        "bestReturn": 0.1759,
                        "finalValue": 117586.0,
                        "dcWinRate": 0.857,
                        "riskVolatility": 0.253,
                        "medianDividend": 0.225,
                        "category": "excluded"
            },
            {
                        "ticker": "QDTY",
                        "tradingDays": 20,
                        "exDivDay": "Thursday",
                        "buyHoldReturn": 0.14679999999999999,
                        "divCaptureReturn": 0.1666,
                        "bestStrategy": "DC",
                        "bestReturn": 0.1666,
                        "finalValue": 116664.0,
                        "dcWinRate": 0.9,
                        "riskVolatility": 0.409,
                        "medianDividend": 0.257,
                        "category": "excluded"
            },
            {
                        "ticker": "AMZW",
                        "tradingDays": 1,
                        "exDivDay": "Monday",
                        "buyHoldReturn": 0.06849999999999999,
                        "divCaptureReturn": 0.018500000000000003,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.06849999999999999,
                        "finalValue": 106852.0,
                        "dcWinRate": 1.0,
                        "riskVolatility": 0.265,
                        "medianDividend": 0.393,
                        "category": "excluded"
            },
            {
                        "ticker": "NFLW",
                        "tradingDays": 1,
                        "exDivDay": "Monday",
                        "buyHoldReturn": 0.0509,
                        "divCaptureReturn": 0.0002,
                        "bestStrategy": "B&H",
                        "bestReturn": 0.0509,
                        "finalValue": 105087.0,
                        "dcWinRate": 1.0,
                        "riskVolatility": 0.297,
                        "medianDividend": 0.459,
                        "category": "excluded"
            }
];

        // Load data immediately
        loadData(fallbackData);

        function loadData(data) {
            currentData = data;
            const topPerformers = data.filter(item => item.category === 'top-performers');
            
            renderTable('top-performers-body', topPerformers, 'top-performers');
            
            // Calculate and display MPT allocation
            calculateMPTAllocation(topPerformers);
            
            // Add click handlers for sorting
            addSortHandlers();
        }

        function addSortHandlers() {
            const headers = document.querySelectorAll('th[data-column]');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.getAttribute('data-column');
                    sortTable(column, header);
                });
            });
        }

        function sortTable(column, headerElement) {
            // Toggle sort direction if same column, otherwise start with ascending
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortDirection = 'asc';
                currentSortColumn = column;
            }

            // Remove existing sort indicators
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            // Add sort indicator to current column
            headerElement.classList.add(currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

            // Sort the data
            const sortedData = [...currentData].sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];

                // Handle different data types
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (currentSortDirection === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });

            // Re-render tables with sorted data
            const topPerformers = sortedData.filter(item => item.category === 'top-performers');
            
            renderTable('top-performers-body', topPerformers, 'top-performers');
        }

        function renderTable(bodyId, data, tableType) {
            const tbody = document.getElementById(bodyId);
            tbody.innerHTML = data.map(item => `
                <tr>
                    <td><a href="https://finance.yahoo.com/quote/${item.ticker}" target="_blank" class="ticker">${item.ticker}</a></td>
                    <td>${item.exDivDay}</td>
                    <td class="${item.buyHoldReturn > 0 ? 'positive' : 'negative'}">${formatPercentage(item.buyHoldReturn)}</td>
                    <td class="${item.divCaptureReturn > 0 ? 'positive' : 'negative'}">${formatPercentage(item.divCaptureReturn)}</td>
                    <td><span class="strategy-chip ${item.bestStrategy === 'B&H' ? 'bh-chip' : 'dc-chip'}" title="${item.bestStrategy === 'B&H' ? 'Buy & Hold: Purchase and hold the ETF for the entire analysis period' : 'Dividend Capture: Buy the morning before ex-dividend date and sell the morning on ex-dividend date to capture dividends while minimizing market exposure'}">${item.bestStrategy}</span></td>
                    <td class="${item.bestReturn > 0 ? 'positive' : 'negative'}">${formatPercentage(item.bestReturn)}</td>
                    <td>${formatPercentage(item.dcWinRate)}</td>
                    <td><span class="risk-tag">${formatPercentage(item.riskVolatility)}</span></td>
                </tr>
            `).join('');
        }

        function formatPercentage(value) {
            return (value * 100).toFixed(2) + '%';
        }

        function formatCurrency(value) {
            return '$' + value.toLocaleString();
        }

        function formatDividend(value) {
            return '$' + value.toFixed(3);
        }

        function calculateMPTAllocation(topPerformers) {
            if (topPerformers.length === 0) return;

            // Add cash and SPY to the mix
            const assets = [
                ...topPerformers.map(etf => ({
                    ticker: etf.ticker,
                    return: etf.bestReturn,
                    risk: etf.riskVolatility,
                    sharpe: etf.bestReturn / etf.riskVolatility,
                    bestStrategy: etf.bestStrategy
                })),
                {
                    ticker: 'CASH',
                    return: 0.045, // 4.5% annual yield
                    risk: 0.0, // 0% risk
                    sharpe: Infinity,
                    bestStrategy: null // Cash doesn't have a strategy
                },
                {
                    ticker: 'SPY',
                    return: 0.12, // 12% annual return
                    risk: 0.20, // 20% risk
                    sharpe: 0.12 / 0.20,
                    bestStrategy: 'B&H' // SPY is always buy and hold
                }
            ];

            // Maximize return while keeping overall portfolio risk under 10%
            const maxPortfolioRisk = 0.10; // 10% risk constraint
            
            // Optimize portfolio with risk constraint (include cash as an option)
            const allocation = optimizePortfolioWithRiskConstraint(assets, maxPortfolioRisk);

            // Calculate portfolio metrics
            const portfolioMetrics = calculatePortfolioMetrics(allocation);

            // Display results
            displayMPTResults(allocation, portfolioMetrics);
        }

        function optimizePortfolio(assets, totalAllocation) {
            // Sort by Sharpe ratio (descending)
            const sortedAssets = [...assets].sort((a, b) => b.sharpe - a.sharpe);
            
            // Simple allocation based on Sharpe ratios with diversification constraints
            const allocation = [];
            let remainingWeight = totalAllocation;
            
            // Limit individual positions (max 25% each for diversification)
            const maxWeight = 0.25;
            
            for (let i = 0; i < sortedAssets.length && remainingWeight > 0.01; i++) {
                const asset = sortedAssets[i];
                
                // Calculate weight based on Sharpe ratio, but cap it
                let weight = Math.min(
                    (asset.sharpe / sortedAssets.reduce((sum, a) => sum + a.sharpe, 0)) * totalAllocation,
                    maxWeight,
                    remainingWeight
                );
                
                // Minimum allocation of 2% if we're including it
                if (weight > 0.02) {
                    allocation.push({
                        ticker: asset.ticker,
                        weight: weight,
                        return: asset.return,
                        risk: asset.risk,
                        sharpe: asset.sharpe,
                        bestStrategy: asset.bestStrategy
                    });
                    remainingWeight -= weight;
                }
            }
            
            // Redistribute any remaining weight proportionally
            if (remainingWeight > 0.01 && allocation.length > 0) {
                const redistributionFactor = 1 + (remainingWeight / allocation.reduce((sum, a) => sum + a.weight, 0));
                allocation.forEach(asset => {
                    asset.weight *= redistributionFactor;
                });
            }

            return allocation;
        }

        function optimizePortfolioWithRiskConstraint(assets, maxRisk) {
            // Debug: Log all assets to see their actual values
            console.log('All assets with return/risk values:');
            assets.forEach(asset => {
                if (asset.ticker !== 'CASH') {
                    console.log(`${asset.ticker}: ${(asset.return*100).toFixed(1)}% return, ${(asset.risk*100).toFixed(1)}% risk`);
                }
            });
            
            // First, identify ETFs that meet diversity criteria: >40% return AND <40% risk
            const qualifyingETFs = assets.filter(asset => 
                asset.ticker !== 'CASH' && 
                asset.ticker !== 'SPY' && 
                asset.return > 0.40 && 
                asset.risk < 0.40
            );
            
            console.log('Qualifying ETFs for mandatory inclusion (>40% return AND <40% risk):', qualifyingETFs.map(etf => 
                `${etf.ticker}: ${(etf.return*100).toFixed(1)}% return, ${(etf.risk*100).toFixed(1)}% risk`
            ));
            
            // Rule 2: Identify ETFs with >30% dividend capture (10% holding regardless of risk)
            const divCaptureETFs = assets.filter(asset => 
                asset.ticker !== 'CASH' && 
                asset.ticker !== 'SPY' && 
                asset.dividendCapture > 0.30 &&
                !qualifyingETFs.some(qual => qual.ticker === asset.ticker) // Don't double-count
            );
            
            console.log('Qualifying ETFs (>40% return AND <40% risk, min 10%):', qualifyingETFs.map(etf => 
                `${etf.ticker}: ${(etf.return*100).toFixed(1)}% return, ${(etf.risk*100).toFixed(1)}% risk`
            ));
            
            console.log('Div Capture ETFs (>30% div capture, 10% holding):', divCaptureETFs.map(etf => 
                `${etf.ticker}: ${(etf.dividendCapture*100).toFixed(1)}% div capture, ${(etf.risk*100).toFixed(1)}% risk`
            ));
            
            // Sort all assets by expected return (descending) for remaining allocation
            const sortedAssets = [...assets].sort((a, b) => b.return - a.return);
            
            // Start with mandatory qualifying ETFs with equal weight
            const allocation = [];
            let totalWeight = 0;
            
            // Step 1: Add all qualifying ETFs with equal initial weights
            if (qualifyingETFs.length > 0) {
                const equalWeight = Math.min(0.80 / qualifyingETFs.length, 0.25); // Max 25% each, up to 80% total
                
                for (const asset of qualifyingETFs) {
                    allocation.push({
                        ticker: asset.ticker,
                        weight: equalWeight,
                        return: asset.return,
                        risk: asset.risk,
                        sharpe: asset.sharpe,
                        bestStrategy: asset.bestStrategy
                    });
                    totalWeight += equalWeight;
                }
                
                // Check if this allocation meets risk constraint
                let portfolioVariance = allocation.reduce((sum, a) => {
                    return sum + Math.pow(a.weight * a.risk, 2);
                }, 0);
                let portfolioRisk = Math.sqrt(portfolioVariance);
                
                console.log(`Initial allocation with ${qualifyingETFs.length} qualifying ETFs:`, 
                           `${(portfolioRisk*100).toFixed(1)}% risk, ${(totalWeight*100).toFixed(1)}% allocated`);
                
                // If initial allocation exceeds risk limit, scale down proportionally
                if (portfolioRisk > maxRisk) {
                    const scaleFactor = maxRisk / portfolioRisk * 0.95; // 95% of max for safety buffer
                    allocation.forEach(asset => {
                        const oldWeight = asset.weight;
                        asset.weight *= scaleFactor;
                        totalWeight = totalWeight - oldWeight + asset.weight;
                    });
                    portfolioRisk = Math.sqrt(allocation.reduce((sum, a) => 
                        sum + Math.pow(a.weight * a.risk, 2), 0));
                    console.log(`Scaled down to meet risk constraint: ${(portfolioRisk*100).toFixed(1)}% risk`);
                }
            }
            
            // Step 2: Try to add remaining high-return assets if we have room
            const remainingAssets = sortedAssets.filter(asset => 
                !qualifyingETFs.some(qual => qual.ticker === asset.ticker) &&
                asset.ticker !== 'CASH' &&
                // Only allow SPY if no qualifying ETFs were found
                (asset.ticker !== 'SPY' || qualifyingETFs.length === 0)
            );
            
            console.log('Remaining assets to consider:', remainingAssets.map(asset => 
                `${asset.ticker}: ${(asset.return*100).toFixed(1)}% return, ${(asset.risk*100).toFixed(1)}% risk`
            ));
            
            for (const asset of remainingAssets) {
                if (totalWeight >= 0.98) break; // Leave room for potential cash
                
                // Try adding this asset with incremental weights
                let testWeight = 0.02; // Start with 2%
                let bestWeight = 0;
                const maxIndividualWeight = 0.25; // Max 25% for any single position
                
                while (testWeight <= maxIndividualWeight && (totalWeight + testWeight) <= 0.98) {
                    // Create test allocation
                    const testAllocation = [...allocation];
                    testAllocation.push({
                        ticker: asset.ticker,
                        weight: testWeight,
                        return: asset.return,
                        risk: asset.risk,
                        sharpe: asset.sharpe,
                        bestStrategy: asset.bestStrategy
                    });
                    
                    // Calculate test portfolio risk
                    const testPortfolioVariance = testAllocation.reduce((sum, a) => {
                        return sum + Math.pow(a.weight * a.risk, 2);
                    }, 0);
                    const testPortfolioRisk = Math.sqrt(testPortfolioVariance);
                    
                    if (testPortfolioRisk <= maxRisk) {
                        bestWeight = testWeight;
                        testWeight += 0.01; // Increase by 1%
                    } else {
                        break;
                    }
                }
                
                // Add the asset with the best weight if it's meaningful
                if (bestWeight >= 0.02) { // Minimum 2% allocation
                    allocation.push({
                        ticker: asset.ticker,
                        weight: bestWeight,
                        return: asset.return,
                        risk: asset.risk,
                        sharpe: asset.sharpe,
                        bestStrategy: asset.bestStrategy
                    });
                    totalWeight += bestWeight;
                    console.log(`Added ${asset.ticker} with ${(bestWeight*100).toFixed(1)}% allocation`);
                }
            }
            
            // Step 3: Add cash if needed to reach 100%
            const remainingWeight = 1.0 - totalWeight;
            if (remainingWeight > 0.01) {
                allocation.push({
                    ticker: 'CASH',
                    weight: remainingWeight,
                    return: 0.045,
                    risk: 0.0,
                    sharpe: Infinity,
                    bestStrategy: null
                });
                console.log(`Added ${(remainingWeight*100).toFixed(1)}% cash to complete allocation`);
            }
            
            // Final portfolio metrics
            const finalVariance = allocation.reduce((sum, a) => sum + Math.pow(a.weight * a.risk, 2), 0);
            const finalRisk = Math.sqrt(finalVariance);
            const finalReturn = allocation.reduce((sum, a) => sum + (a.weight * a.return), 0);
            
            console.log(`Final portfolio: ${(finalReturn*100).toFixed(1)}% expected return, ${(finalRisk*100).toFixed(1)}% risk`);
            
            return allocation;
        }

        function calculatePortfolioMetrics(allocation) {
            const portfolioReturn = allocation.reduce((sum, asset) => sum + (asset.weight * asset.return), 0);
            
            // Simplified portfolio risk calculation (assuming some correlation)
            const portfolioVariance = allocation.reduce((sum, asset) => {
                return sum + Math.pow(asset.weight * asset.risk, 2);
            }, 0);
            const portfolioRisk = Math.sqrt(portfolioVariance);
            
            const sharpeRatio = portfolioRisk > 0 ? portfolioReturn / portfolioRisk : 0;

            return {
                expectedReturn: portfolioReturn,
                risk: portfolioRisk,
                sharpeRatio: sharpeRatio
            };
        }

        function displayMPTResults(allocation, metrics) {
            // Sort allocation by weight (descending)
            const sortedAllocation = allocation.sort((a, b) => b.weight - a.weight);

            // Display allocation with progress bars
            const allocationDiv = document.getElementById('portfolio-allocation');
            allocationDiv.innerHTML = sortedAllocation.map(asset => {
                const weightPercent = (asset.weight * 100).toFixed(1);
                // Display CASH more intuitively
                let displayName;
                if (asset.ticker === 'CASH') {
                    displayName = 'üí∞ Cash (Risk-Free)';
                } else {
                    // Make ticker clickable for non-cash assets
                    displayName = `<a href="https://finance.yahoo.com/quote/${asset.ticker}" target="_blank" class="ticker">${asset.ticker}</a>`;
                    // Add strategy chip if available
                    if (asset.bestStrategy) {
                        displayName += ` <span class="strategy-chip ${asset.bestStrategy === 'B&H' ? 'bh-chip' : 'dc-chip'}" title="${asset.bestStrategy === 'B&H' ? 'Buy & Hold: Purchase and hold the ETF for the entire analysis period' : 'Dividend Capture: Buy the morning before ex-dividend date and sell the morning on ex-dividend date to capture dividends while minimizing market exposure'}">${asset.bestStrategy}</span>`;
                    }
                }
                return `
                    <div class="allocation-row">
                        <span class="allocation-name">${displayName}</span>
                        <span class="allocation-percent">${weightPercent}%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${weightPercent}%"></div>
                    </div>
                `;
            }).join('');

            // Display metrics in grid layout
            const metricsDiv = document.getElementById('portfolio-metrics');
            metricsDiv.innerHTML = `
                <div class="stat-box">
                    <div class="stat-label">Expected Return</div>
                    <div class="stat-value">${formatPercentage(metrics.expectedReturn)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Portfolio Risk</div>
                    <div class="stat-value">${formatPercentage(metrics.risk)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Sharpe Ratio</div>
                    <div class="stat-value">${metrics.sharpeRatio.toFixed(2)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Diversification</div>
                    <div class="stat-value">${allocation.length} assets</div>
                </div>
            `;

            // Show the widget (it's already visible in this version)
            
            // Animate progress bars
            setTimeout(() => {
                const bars = document.querySelectorAll('.progress-fill');
                bars.forEach((bar, index) => {
                    const width = bar.style.width;
                    bar.style.width = '0%';
                    setTimeout(() => {
                        bar.style.width = width;
                    }, index * 150);
                });
            }, 100);
        }
    </script>
</body>
</html>
